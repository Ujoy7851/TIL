# 프로그래머스 레벨 1

### 같은 숫자는 싫어

```javascript
function solution(arr)
{
  return arr.filter((a, i) => a !== arr[i + 1]);
}
```
- filter() 함수를 사용해 다음 요소와 같은 요소만을 남긴다.

### 모의고사
```javascript
function solution(answers) {
  const arr1 = [1, 2, 3, 4, 5];
  const arr2 = [2, 1, 2, 3, 2, 4, 2, 5];
  const arr3 = [3, 3, 1, 1, 2, 2, 4, 4, 5, 5];

  const scores = [
    answers.filter((a, i) => a === arr1[i % arr1.length]).length,
    answers.filter((a, i) => a === arr2[i % arr2.length]).length,
    answers.filter((a, i) => a === arr3[i % arr3.length]).length
  ];

  return scores.map((s, i) => s === Math.max(...scores) ? i + 1 : undefined).filter(s => !!s);
}
```
- filter() 함수로 패턴과 일치하는 answers의 요소를 남기고, 배열의 길이로 정답 갯수를 구한다.
- map(), filter() 함수를 조합해 최고점을 가지는 배열의 인덱스만 반환

### 124 나라의 숫자
```javascript
function solution(n) {
  var answer = '';
  while(n > 0) {
      var rem = n % 3;
      n = Math.floor(n / 3);
      answer = '412'.charAt(rem) + answer;
      if(rem === 0) --n;
  }
  return answer;
}
```

**다른 사람의 풀이**
```javascript
function change124(n) {
  return n === 0 ? '' : change124(parseInt((n - 1) / 3)) + [1, 2, 4][(n - 1) % 3];
}
```
- 입력 값을 3으로 나누면서 몫이 0보다 클때까지 나머지를 정답 문자열의 앞쪽에 추가하는 것을 반복한다.
- 단, 나머지가 0일 경우 4로 바꿔주고, 몫에서 1을 빼준다.
- 나누기 연산의 결과를 정수로 만드는 법: `Math.floor()` 또는 `parseInt()`

### 2016
```javascript
function solution(a, b) {
  return ['SUN','MON','TUE','WED','THU','FRI','SAT'][new Date(2016, a - 1, b).getDay()];
}
```
- Date 객체의 getDay() 메소드로 요일을 가져올 수 있다.
- Date 객체를 생성할 때 '월'이 0부터 시작한다는 점 주의하기

### 가운데 글자 가져오기
```javascript
function solution(s) {
  const middle = Math.floor((s.length - 1) / 2);
  return s.slice(middle, s.length % 2 === 0 ? middle + 2 : middle + 1);
}
```
**다른 사람의 풀이**
```javascript
function solution(s) {
    return s.substr(Math.ceil(s.length / 2) - 1, s.length % 2 === 0 ? 2 : 1);
}
```
- `Math.floor()`나 `Math.ceil()` 함수를 사용해 문자열의 중간을 구한다.
- 문자열의 일부를 가져올 때는 `slice` 또는 `substr` 함수를 사용하면 된다.

### 나누어 떨어지는 숫자 배열
```javascript
function solution(arr, divisor) {
    var result = arr.filter(a => a % divisor === 0);
    return result.length === 0 ? [-1] : result.sort((a, b) => a - b);
}
```
- 배열의 정렬은 `sort()` 함수를 사용한다. 함수 안에 비교 함수를 넣지 않으면 문자열의 유니코드를 기준으로 정렬한다.

### 두 정수 사이의 합
```javascript
function solution(a, b) {
  [a, b] = a > b ? [b, a] : [a, b];
  return [...Array(b - a + 1).keys()].map(i => i + a).reduce((a, c) => a + c);
}
```
- Array(N) 생성자로 길이가 N인 배열을 생성해서 index를 받아와 시작점에 index를 더해 배열을 생성
- reduce 함수로 배열 전체 합을 구한다

**다른 사람의 풀이 1**
```javascript
function adder(a, b){
    return (a+b)*(Math.abs(b-a)+1)/2;
}
```
- 가우스 공식을 이용한 간단한 풀이

**다른 사람의 풀이 2**
```javascript
function adder(a, b, s = 0){
  for (var i = Math.min(a, b); i <= Math.max(a, b); i++) s += i;
  return s;
}
```
for문을 이용해 사잇값까지 모두 더하는 풀이

### 크레인 인형뽑기 게임
```javascript
function solution(board, moves) {
  let basket = [];
  let result = 0;
  const getTop = (col) => {
    for(let i = 0; i < board.length; i++) {
      if(board[i][col] !== 0) {
        return [board[i][col], i];
      }
    }
    return 0;
  }

  moves.map(m => {
    let top = getTop(m - 1);
    if(top !== 0) {
      board[top[1]][m - 1] = 0;
      if(top[0] === basket[basket.length - 1]) {
        basket.pop();
        result += 2;
      } else {
        basket.push(top[0]);
      }
    }
  });
```

**다른 사람의 풀이 2**
```javascript
const transpose = matrix =>
    matrix.reduce(
        (result, row) => row.map((_, i) => [...(result[i] || []), row[i]]),
        []
    );

const solution = (board, moves) => {
    const stacks = transpose(board).map(row =>
        row.reverse().filter(el => el !== 0)
    );
    const basket = [];
    let result = 0;

    for (const move of moves) {
        const pop = stacks[move - 1].pop();
        if (!pop) continue;
        if (pop === basket[basket.length - 1]) {
            basket.pop();
            result += 2;
            continue;
        }
        basket.push(pop);
    }

    return result;
};
```
- reduce 함수를 통해 만든 전치 행렬을 활용한 풀이
- `const transpose = m => m[0].map((x,i) => m.map(x => x[i]))` 이런식으로 전치 행렬을 구할 수도 있다.